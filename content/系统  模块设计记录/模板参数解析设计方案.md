# 消息模版参数解析方案

> 本博客因故不涉及任何具体代码，只介绍方案本身。

## 业务背景

在后台管理系统或营销系统中，消息触达是一个基础功能。随着业务迭代，我们通常会面临消息类型增多的问题：从最基础的任务通知，扩展到实体状态变更、用户互动提醒、系统公告等。

在早期阶段，我们往往直接在业务代码中拼接字符串。但这种做法随着模版数量的增加，会暴露出两个明显的工程问题：

1. **逻辑耦合**：业务主流程为了组装一条消息，往往需要额外查询许多非核心数据（例如为了发一条订单通知，需要额外查一次用户等级）。这不仅污染了核心业务代码，还可能影响接口响应耗时。
2. **维护成本高**：当模版中的文案发生变更，或者某个参数（如“用户昵称”）的获取逻辑发生变化时，我们需要在大量散落的业务代码中进行查找和修改，容易出现遗漏。

为了解决上述问题，我们需要将“模版定义”与“数据获取”分离，设计一套通用的模版参数解析方案。

## 设计目标

这套方案的核心设计目标主要有三点：

- **解耦**：业务方可以直接提供参数值，也可以只提供上下文而无需关心模版具体需要哪些参数。
- **健壮性**：支持多种取值策略降级，并在应用启动阶段进行完整性自检，避免运行时出现参数缺失。
- **性能**：支持批量解析，避免在处理复杂模版时产生重复次查询问题。

## 核心架构

整体流程为：**输入上下文 -> 识别参数 -> 策略分发 -> 渲染结果**。

### 1. 参数定义的枚举化

我们不再使用散乱的字符串来管理参数，而是通过枚举类统一维护所有支持的参数定义。每个枚举实例不仅仅是一个标识符，它还封装了该参数的基础元数据：

*   **默认值**：当所有解析手段都失效时使用的静态兜底值。
*   **默认Supplier**：一个轻量级的函数接口，用于处理简单的逻辑（如获取当前时间格式化字符串），不需要依赖复杂的外部服务。
*   **透传标识**：用于标记该参数是否强制要求业务方直接传入。

### 2. 上下文容器 

为了在业务主流程和参数解析器之间传递数据，我们设计了一个通用的上下文容器。这个容器主要包含两部分数据：

*   **直传参数集合**：业务方已经计算好，直接通过键值对传入的参数值。这部分数据的优先级最高。
*   **上下文实体集合**：业务方提供的原始数据对象（如 UserInfo 对象、Order 实体等）。解析器将利用这些对象进行进一步的计算或属性提取。为了保证类型安全，我们使用泛型Key来存取这些对象。

### 3. 基于注解的解析器注册机制

这是系统中最核心的部分，用于处理复杂的参数获取逻辑。

我们定义特定的注解，用于标记在Spring管理的Bean的方法上。该注解包含两个核心属性：

*   **支持的参数列表**：声明该方法能够解析哪些参数枚举。
*   **优先级**：当多个解析器都能处理同一个参数时，通过优先级决定调用顺序。

被标记的方法需要遵循特定的签名规范：接收上下文容器作为入参，返回一个包含参数枚举与参数值映射的Map。这种设计允许一个方法同时计算并返回多个相关联的参数，从而极大提高了执行效率。

### 4. 启动时的自检与注册

为了保证系统的健壮性，我们利用Spring容器启动后的回调接口（如 `InitializingBean` 或 `ApplicationListener`）来实现解析器的自动扫描与注册。

**注册流程**：

1.  扫描所有包含自定义注解的Bean。
2.  通过反射获取被标记的方法，校验方法签名是否符合规范。
3.  将方法封装为执行单元，按优先级排序后注册到内存中的调度表中。

**完整性校验流程**：
在注册完成后，系统会遍历所有的参数枚举，检查每一个参数是否满足以下条件之一：

*   已被某个解析器覆盖。
*   拥有默认值或默认Supplier。
*   被标记为强制透传。

如果存在“孤儿参数”（即没有任何方式能获取到值的参数），系统将抛出异常并阻止应用启动。这有效地将运行时可能出现的模板渲染错误提前到了编译/部署阶段。

### 5. 运行时的编排逻辑

当业务方发起模板渲染请求时，核心编排器按照以下步骤执行：

1.  **直传优先**：首先检查上下文容器中的“直传参数集合”，如果存在对应的参数值，直接采用，不再进行后续计算。
2.  **批量解析**：对于尚未获取值的参数，编排器会查找注册的解析器列表。系统会计算“当前缺失参数”与“解析器支持参数”的交集。如果存在交集，则调用对应的解析器方法。解析器从上下文中取出实体对象，执行业务逻辑，返回结果Map。
3.  **默认值兜底**：如果经过上述步骤后仍有参数未被赋值，系统将尝试调用参数枚举中定义的默认Supplier或使用静态默认值。
4.  **最终渲染**：将所有获取到的参数值替换到模板中，完成渲染。

## 实际使用体验

经过封装后，业务方的调用代码变得非常简洁。

假设我们需要发送一条包含用户昵称、当前时间和任务名称的消息：

```java
// 业务代码示例
public void sendTaskNotification(User user, Task task) {
    // 1. 构建上下文，放入实体对象
    ResolutionContext ctx = new ResolutionContext();
    ctx.putEntity(user);
    ctx.putEntity(task);
    ctx.putParam(ParamEnum.EXAMPLE, "value");
    
    // 2. 调用服务，传入模版ID和上下文
    // 引擎会自动解析 {USER_NAME} (来自UserResolver), {TASK_NAME} (来自TaskResolver)
    // 以及 {CURRENT_TIME} (来自通用的TimeResolver)
    messageService.send(Template.TASK_ASSIGNED, Template.USER_INFO, ctx);
}
```

## 总结

这套方案有这么几个好处：

- 不再需要关心模版细节，只需提供当前环境下的实体数据。
- 参数解析逻辑收敛在各个 Resolver 中，修改一处即可全局生效。
- 启动时的完整性校验保证了系统的可靠性。